# 缓存双写一致性问题

缓存双写一致性问题是指当系统中存在多级缓存时，在缓存数据更新时，可能会出现不同级别缓存数据不一致的情况。这种情况下，缓存数据更新了，但是下一次查询时，由于缓存数据不一致，导致从缓存读取的数据是错误的。

例如，在一个系统中，存在两级缓存：本地缓存和远程缓存。当一个数据在本地缓存中被更新时，远程缓存中的相应数据也需要更新，否则会出现缓存数据不一致的情况。但是，如果更新本地缓存和远程缓存的操作不是原子性的，可能会导致远程缓存中的数据没有被更新，从而导致缓存数据不一致的问题。

缓存双写一致性问题的解决方法包括：

1. 强制更新远程缓存：在更新本地缓存后，立即更新远程缓存。这样可以保证缓存数据的一致性，但会增加系统开销，降低性能。
2. 延迟更新远程缓存：将远程缓存的更新延迟一段时间，等到本地缓存中的数据被使用时再更新远程缓存。这种方法可以减少系统开销，但可能会导致一段时间内的缓存数据不一致。
3. 使用分布式锁：在更新缓存时，使用分布式锁来确保更新操作的原子性。这种方法可以保证缓存数据的一致性，但会增加系统开销，降低性能。

## 读写缓存

### 同步直写策略

同步直写（Synchronous Write-Through）是一种缓存更新策略，用于解决缓存双写一致性问题。

在同步直写策略下，每次数据写操作会同时更新缓存和数据库。具体来说，当发生写操作时，首先将数据写入缓存，然后再将数据写入数据库。只有当数据库确认数据写入成功后，才返回操作成功。

这种策略确保了缓存和数据库的一致性。但是，由于每次写操作都需要等待数据库的确认，因此它的性能较低，可能会导致系统响应时间变慢。同时，如果缓存中的数据过多，会占用大量内存资源，导致性能下降。

因此，同步直写策略只适用于数据量较小、对数据一致性要求较高、写操作不频繁的场景。对于数据量较大、写操作频繁的场景，可以采用其他更新策略，如异步写或缓存失效等。

### 异步缓写策略

异步缓写策略是一种缓存双写一致性问题的解决方案。在这种策略下，写入请求首先被写入到缓存中，并立即返回成功响应，同时异步地将数据写入到持久化存储中。

异步缓写策略相对于同步直写策略来说，具有更好的性能和可伸缩性，因为写入请求不需要等待数据写入持久化存储之后才返回成功响应。但是，由于数据可能会在缓存中被写入，而在异步写入到持久化存储之前就发生故障，所以可能会存在一段时间的数据不一致性。

为了避免这种情况，通常会采用一些措施，如在缓存中写入数据时使用持久化的方式，以及在数据写入持久化存储之前将其存储在一个内存队列中，以确保数据不会在丢失。此外，还可以在写入缓存和写入持久化存储之间添加一层队列，以确保写入请求的顺序。

### 双检加锁策略

双检加锁策略是一种解决并发编程中线程安全问题的方法，它结合了懒加载和线程同步的优势，既能保证只有在需要的时候才会创建对象，又能保证线程安全。

在实现过程中，需要先检查对象是否已经创建，如果没有，再加锁创建对象。同时为了提高效率，可以再加一个判断，如果对象已经创建，直接返回已有的对象，避免重复创建。这样既能保证线程安全，又能保证效率。因此，双检加锁策略通常被广泛应用于单例模式的实现。

## 缓存双写一致性的更新策略

### 先更新数据库,再更新缓存

- 异常情况一：更新mysql后，redis因为某些原因更新失败。
- 异常情况二：多线程更新，在事务的影响下，redis和mysql最终数据不一致

### 先更新缓存,再更新数据库

多线程更新，在事务的影响下，redis和mysql最终数据不一致

### 先删除缓存，再更新数据库

-  请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql......A还么有彻底更新完mysql，还没commit
- 请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)
- 请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)
- 请求B将旧值写回redis缓存
- 请求A将新值写入mysql数据库 

如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis，导致A白干了

#### 延时双删

